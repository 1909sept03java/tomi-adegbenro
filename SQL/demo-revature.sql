--DB CREATION SCRIPTS OFTEN BEGIN WITH DROP STATEMETNS
--AVOID CLASHES WITH EXISTIG TABLES

DROP TABLE BEAR;
/
DROP TABLE BEAR_TYPE;
/
DROP TABLE CAVE;
/
DROP TABLE BEEHIVE;
/
DROP TABLE BEAR_BEEHIVE;
/
--TABLE CREATION WIT PRIMARY KEYS
CREATE TABLE BEAR(
	BEAR_ID INTEGER PRIMARY KEY,
    BEAR_NAME VARCHAR2(100), --100 CHARACTERS OF SPACE
    --VARCHAR2 INTERPRETS NULL AND EMPTY STRING AS THE SAME VALUE, UNLIKE VARCHAR
    BIRTHDATE DATE,
    WEIGHT NUMBER(6, 2) DEFAULT 200.00,
    BEAR_TYPE_ID INTEGER NOT NULL, -- APPLYING A NOT NULL CONSTRAINT TO THIS COLUMN WILL BE FK
    CAVE_ID INTEGER --WILL BE A NULLABLE FK
);
/

CREATE TABLE BEAR_TYPE(
	BEAR_TYPE_ID INTEGER PRIMARY KEY,
    BEAR_TYPE_NAME VARCHAR2(100)
);
/
CREATE TABLE CAVE(
	CAVE_ID INTEGER PRIMARY KEY,
    CAVE_NAME VARCHAR2(100),
    MAX_BEARS INTEGER DEFAULT 4
);
/
CREATE TABLE BEEHIVE(
	BEEHIVE_ID INTEGER PRIMARY KEY,
    HONEY_AMOUNT NUMBER(5, 2) DEFAULT 75.00
);
/
CREATE TABLE BEAR_BEEHIVE(
	BEAR_ID INTEGER,
    BEEHIVE_ID INTEGER
    PRIMARY KEY(BEAR_ID, BEEHIVE_ID) --COMPOSITE PRIMARY KEY
);
/
--DONE AFTER THE FACT: WS NOT INCLUDED WHEN CREATING BEAR_BEEHIVE TABLE
ALTER TABLE BEAR_BEEHIVE
ADD CONSTRAINT BB_composite_key PRIMARY KEY (BEAR_ID, BEEHIVE_ID);
/

-- FOREIGN KEY CONSTRAINTS
--CONSTRAINTS: RULE PLACED ON THE CONTENTS OF A TABLE, LIMITING WHAT MAY BE INSERTED: E.G(INCLUDES NOT NULL, UNIQUE, PRIMARY KEY, FOREIGN KEY

ALTER TABLE BEAR
ADD CONSTRAINT FK_BEAR_BEAR_TYPE
FOREIGN KEY (BEAR_TYPE_ID) REFERENCES BEAR_TYPE(BEAR_TYPE_ID);
/

ALTER TABLE BEAR
ADD CONSTRAINT FK_BEAR_CAVE
FOREIGN KEY (CAVE_ID) REFERENCES CAVE(CAVE_ID);
/

ALTER TABLE BEAR_BEEHIVE
ADD CONSTRAINT FK_BEAR_BEAR_BEEHIVETYPE
FOREIGN KEY (BEAR_ID) REFERENCES BEAR(BEAR_ID);
/

ALTER TABLE BEAR_BEEHIVE
ADD CONSTRAINT FK_BEEHIVE_BEAR_BEEHIVETYPE
FOREIGN KEY (BEEHIVE_ID) REFERENCES BEEHIVE(BEEHIVE_ID);
/
--ADD SOME DATA - BE CAREFUL ABOUNT INSERTION ORDER
-- TWO WATS TO ADD: BY FILLING ALL COLUMNS OR SPECIFY WHICH COLUMNS TO FILL

INSERT INTO BEAR_TYPE VALUES (1, 'Grizzly');
INSERT INTO BEAR_TYPE (BEAR_TYPE_ID, BEAR_TYPE_NAME) VALUES (2, 'Sun');

INSERT ALL
INTO CAVE
VALUES(1, 'Queens College', 15)
INTO CAVE (CAVE_ID, CAVE_NAME)
VALUES (37, 'Awesome Cave')
SELECT * FROM DUAL; -- DUAL IS A DMMY TABLE, PLSQL USUE IT TO MAKE STATEMENTS FIT QUERY FORMAT

--SELECT * FROM DUAL;
SELECT * FROM CAVE;

INSERT ALL
INTO BEAR(BEAR_ID, BEAR_NAME, BIRTHDATE, BEAR_TYPE_ID, CAVE_ID)
VALUES (72, 'Barry', TO_DATE('2000-10-08', 'yyyy-mm-dd'), 1 ,37)
INTO BEAR(BEAR_ID, BEAR_NAME, BIRTHDATE, BEAR_TYPE_ID, CAVE_ID)
VALUES (2, 'Bob', TO_DATE('2000-07-31', 'yyyy-mm-dd'), 1 ,37)
INTO BEAR(BEAR_ID, BEAR_NAME, BIRTHDATE, BEAR_TYPE_ID, CAVE_ID)
VALUES (8, 'Bernice', TO_DATE('1980-09-08', 'yyyy-mm-dd'), 1 ,1)
INTO BEAR(BEAR_ID, BEAR_NAME, BIRTHDATE, BEAR_TYPE_ID, CAVE_ID)
VALUES (45, 'Beatrice', TO_DATE('2005-03-09', 'yyyy-mm-dd'), 1 ,37)
INTO BEAR(BEAR_ID, BEAR_NAME, BIRTHDATE, BEAR_TYPE_ID, CAVE_ID)
VALUES (89, 'Yogi', TO_DATE('1958-08-18', 'yyyy-mm-dd'), 2 ,1)
SELECT * FROM DUAL;
--SELECT * FROM BEAR;
/
INSERT INTO BEAR(BEAR_ID, BEAR_NAME, BIRTHDATE, BEAR_TYPE_ID)
VALUES (56, 'Bill', TO_DATE('2000-10-08', 'yyyy-mm-dd'), 1);
/
--SET UP SEQUENCES TO PRODUCE PRIARY KEYS
CREATE SEQUENCE SQ_BEAR_PK
START WITH 1000
INCREMENT BY 1;
/
CREATE SEQUENCE SQ_BEEHIVE_PK
START WITH 1000
INCREMENT BY 1;
/
CREATE SEQUENCE SQ_BEAR_TYPE_PK
START WITH 1000
INCREMENT BY 1;
/
CREATE SEQUENCE SQ_CAVE_PK
START WITH 1000
INCREMENT BY 1;
/
--PRACTICING INSERT AND DELETE
INSERT INTO BEAR (BEAR_TYPE_ID, BEAR_NAME, WEIGHT) VALUES (2, 'JANGO', 450);
DELETE FROM BEAR WHERE BEAR_NAME = 'JANGO';
/

--TRIGGERS: BLOCKS OF CODE THAT WILL EXECUTE IN RESPONSE TO A DML STATEMENT
--(INSERT, UPDATE, DELETE)
--CAN CREATE "BEFORE" OR "AFTER TRIGGERS

CREATE OR REPLACE TRIGGER TR_INSERT_BEAR
BEFORE INSERT ON BEAR --SPECIFY OPERATION, BEFORE/AFTER, AND TABLE
FOR EACH ROW
BEGIN
    SELECT SQ_BEAR_PK.NEXTVAL INTO :NEW.BEAR_ID FROM DUAL;
END;
/

CREATE OR REPLACE TRIGGER TR_INSERT_BEAR_TYPE
BEFORE INSERT ON BEAR_TYPE --SPECIFY OPERATION, BEFORE/AFTER, AND TABLE
FOR EACH ROW
BEGIN
    SELECT SQ_BEAR_TYPE_PK.NEXTVAL INTO :NEW.BEAR_TYPE_ID FROM DUAL;
END;
/
CREATE OR REPLACE TRIGGER TR_INSERT_CAVE
BEFORE INSERT ON CAVE --SPECIFY OPERATION, BEFORE/AFTER, AND TABLE
FOR EACH ROW
BEGIN
    SELECT SQ_CAVE_PK.NEXTVAL INTO :NEW.CAVE_ID FROM DUAL;
END;
/
CREATE OR REPLACE TRIGGER TR_INSERT_BEEHIVE
BEFORE INSERT ON BEEHIVE --SPECIFY OPERATION, BEFORE/AFTER, AND TABLE
FOR EACH ROW
BEGIN
    SELECT SQ_BEEHIVE_PK.NEXTVAL INTO :NEW.BEEHIVE_ID FROM DUAL;
END;
/

--TRY IT OUT. SEE SEQUENCING IN ACTION!
INSERT INTO BEEHIVE (HONEY_AMOUNT) VALUES (58.05);
INSERT INTO BEEHIVE (HONEY_AMOUNT) VALUES (580.05);
/

--FIND HOMELESS BEAR A PLACE TO LIVE
SELECT * FROM BEAR WHERE CAVE_ID IS NULL;
/
UPDATE BEAR
SET CAVE_ID = 1
WHERE CAVE_ID IS NULL;
/

--SELECT STATEMENTS
--SELECT ALL GRIZZY BEARS
SELECT BEAR_NAME, BIRTHDATE FROM BEAR
WHERE BEAR_TYPE_ID = 1
ORDER BY BEAR_NAME; --ASCENDING IS DEFAULT, USE 'DESC' FOR DESCENDING ORDER

--SELECT ALL BEARS, ORDERED BY WEIGHT AND BIRTHDAY
SELECT * FROM BEAR
ORDER BY WEIGHT, BIRTHDATE;

--HOW MANY BEARS PER CAVE?
SELECT CAVE_NAME, COUNT(BEAR.CAVE_ID) AS NUMBEAR
FROM BEAR
INNER JOIN CAVE ON BEAR.CAVE_ID = CAVE.CAVE_ID
GROUP BY CAVE_NAME, BEAR.CAVE_ID;


--ALL CAVES WITH MORE THAN THREE BEARS
SELECT CAVE_ID, COUNT(BEAR_ID) AS NUMBEAR
FROM BEAR
GROUP BY CAVE_ID
HAVING COUNT(BEAR_ID) > 2;


--VIEWS

--HOW MANY BEARS PER CAVE? VIEW edition
CREATE OR REPLACE VIEW VW_BEARS_PER_CAVE(CAVE, NUMBEAR)
AS 
SELECT CAVE_NAME, COUNT(BEAR.CAVE_ID)
FROM BEAR
INNER JOIN CAVE ON BEAR.CAVE_ID = CAVE.CAVE_ID
GROUP BY CAVE_NAME, BEAR.CAVE_ID;

SELECT * FROM VW_BEARS_PER_CAVE;

-- DROP VIEW VW_BEARS_PE_CAVE;

--USER-DERFINED FUNCTIONS
--MAX OF TWO NUMBERS (COULD WE USE THS SYSTEM-DEFINED FUNCTION? YES! WE COULD!)
CREATE OR REPLACE FUNCTION FIND_MAX_NUMBER(X IN NUMBER, Y IN NUMBER)
RETURN NUMBER
IS
Z NUMBER;
BEGIN
    IF X>Y THEN
    Z := X; --PL/SQL ASSIGNMENT OPERATOR IS :=
    ELSE
    Z := Y;
    END IF;
    RETURN Z;
END;

--CALL OUR FUNCTION FIND_MAX_NUMBER
DECLARE 
FIRST_NUM NUMBER;
SECOND_NUM NUMBER;
MAX_NUM NUMBER;
BEGIN
    FIRST_NUM := 22;
    SECOND_NUM := 42;
    MAX_NUM := FIND_MAX_NUMBER(FIRST_NUM, SECOND_NUM);
    DBMS_OUTPUT.PUT_LINE('MAX: '||MAX_NUM); --JUST LIKE A SYSOUT IN JAVA
END;

--CURSOR: POINTER TO THE "ACTIVE REGION" OF THE DATABASE (LIKE THE RESULT SET OF A QUERY)
--USE CURSORS TO MOVE THROUGH RESULT SETS AND PROCESS EACH LINE
--IMPLICIT CURSORS ARE USED BY THE DB TO SUPPORT QUERYING, YOU CAN ALSO DEFINE EXPLICIT CURSORS
--DEFINE YOUR OWN OR USE SYS_REFCURSOR (ALREADY THERE)
CREATE OR REPLACE FUNCTION PRINT_ALL_BEARS
RETURN SYS_REFCURSOR
IS
S SYS_REFCURSOR;
BEGIN
    OPEN S FOR
    SELECT BEAR_ID, BEAR_NAME FROM BEAR;
    RETURN S;
END;

--INVOKE PRINT_ALL_BEARS    
DECLARE
S SYS_REFCURSOR;
SOME_ID BEAR.BEAR_ID%TYPE; -- DECLARES THAT SOME_ID IS OF THE SAME DATATYPE AS BEAR.BEAR_ID
SOME_NAME BEAR.BEAR_NAME%TYPE; -- DECLARES THAT SOME_ID IS OF THE SAME DATATYPE AS BEAR.BEAR_ID
BEGIN
    S := PRINT_ALL_BEARS;
    LOOP
    FETCH S INTO SOME_ID, SOME_NAME; -- GRAB VALUES IN COLUMNS OF NEXT ROW IN ACTIVE SET
    EXIT WHEN S%NOTFOUND;
    DBMS_OUTPUT.PUT_LINE('ID : '||SOME_ID||', NAME: '||SOME_NAME);
    END LOOP;
    CLOSE S;
END;

--MORE ON FUNCTIONS
--Q1 RETURN THE SECOND HEAVIEST BEAR
--CREATED FUNCTION TO PULL MAX VALUE
CREATE OR REPLACE FUNCTION FIND_MAX_WEIGHT --fINDING THE MAX WEIGHT
RETURN SYS_REFCURSOR
IS
S SYS_REFCURSOR;
BEGIN
    OPEN S FOR
    SELECT BEAR_NAME, WEIGHT FROM BEAR WHERE WEIGHT = (SELECT MAX(WEIGHT) FROM BEAR);
    RETURN S;
END;

--CREATED FUNCTION TO TRY AND QUERY A CURSOR **STILL IN PROGRESS
CREATE OR REPLACE FUNCTION FIND_MAX_WEIGHT_CURSOR(S IN SYS_REFCURSOR) --fINDING THE MAX WEIGHT
RETURN SYS_REFCURSOR
IS
S SYS_REFCURSOR;
BEGIN
    OPEN S FOR
    SELECT BEAR_NAME, WEIGHT FROM BEAR WHERE WEIGHT = (SELECT MAX(WEIGHT) FROM BEAR);
    RETURN S;
END;

--Q1 ANSWER
CREATE OR REPLACE FUNCTION FIND_SECOND_HEAVIEST_WEIGHT --QUERY MAX WEIGHT NESTED IN QUERY FOR ALL ENTIRIES BUT THE MAX WEIGHT
RETURN SYS_REFCURSOR
IS
S SYS_REFCURSOR;
BEGIN
    OPEN S FOR
    SELECT BEAR_NAME, WEIGHT FROM (SELECT BEAR_NAME, WEIGHT FROM BEAR WHERE WEIGHT != (SELECT MAX(WEIGHT) FROM BEAR))WHERE WEIGHT = (SELECT MAX(WEIGHT) FROM (SELECT BEAR_NAME, WEIGHT FROM BEAR WHERE WEIGHT != (SELECT MAX(WEIGHT) FROM BEAR)));
    RETURN S;
END;

DECLARE
S SYS_REFCURSOR;
SOME_NAME BEAR.BEAR_NAME%TYPE; -- DECLARES THAT SOME_NAME IS OF THE SAME DATATYPE AS BEAR.BEAR_NAME
SOME_WEIGHT BEAR.WEIGHT%TYPE; -- DECLARES THAT SOME_WEIGHT IS OF THE SAME DATATYPE AS BEAR.WEIGHT
BEGIN
    --S := FIND_MAX_WEIGHT;
    S := FIND_ALL_BUT_MAX_WEIGHT;
    LOOP
    FETCH S INTO SOME_NAME, SOME_WEIGHT; -- GRAB VALUES IN COLUMNS OF NEXT ROW IN ACTIVE SET
    EXIT WHEN S%NOTFOUND;
    DBMS_OUTPUT.PUT_LINE('NAME : '||SOME_NAME||', WEIGHT: '||SOME_WEIGHT);
    END LOOP;
    CLOSE S;
END;

--TROUBLESHOOTING STEPS
SELECT BEAR_NAME, WEIGHT FROM BEAR WHERE WEIGHT = (SELECT MAX(WEIGHT)FROM BEAR);
UPDATE BEAR SET WEIGHT = 600 WHERE BEAR_NAME='Bernice';
/

--Q2 RETURN BEARS WHO ARE SMALLER THAN THE AVERAGE IN THERI CAVE
--CREATIG FUCNTION BEARS_LESS_THAN_AVERAGE
CREATE OR REPLACE FUNCTION LESS_THAN_AVERAGE_BEARS (C_ID IN NUMBER)
RETURN SYS_REFCURSOR
IS
S SYS_REFCURSOR;
BEGIN
    --CAVE_ID := C;
    OPEN S FOR
    --SELECT BEAR_NAME, WEIGHT FROM BEAR WHERE CAVE_ID = C_ID GROUP BY BEAR_NAME, WEIGHT HAVING WEIGHT > AVG(WEIGHT);
    SELECT BEAR_NAME, WEIGHT, CAVE_ID FROM BEAR WHERE WEIGHT < (SELECT AVG(WEIGHT) FROM BEAR) GROUP BY CAVE_ID, BEAR_NAME, WEIGHT HAVING CAVE_ID = C_ID;
    RETURN S;
END;

--CALLING FUNCTION LESS_THAN_AVERAGE_BEARS
DECLARE
S SYS_REFCURSOR;
SOME_NAME BEAR.BEAR_NAME%TYPE; -- DECLARES THAT SOME_NAME IS OF THE SAME DATATYPE AS BEAR.NAME
SOME_WEIGHT BEAR.WEIGHT%TYPE; -- DECLARES THAT SOME_WEIGHT IS OF THE SAME DATATYPE AS BEAR.WEIGHT
SOME_CAVE_ID BEAR.CAVE_ID%TYPE; -- DECLARES THAT SOME_CAVE_ID IS OF THE SAME DATATYPE AS BEAR.CAVE_ID
BEGIN
    S := LESS_THAN_AVERAGE_BEARS(37);
    LOOP
    FETCH S INTO SOME_NAME, SOME_WEIGHT, SOME_CAVE_ID; -- GRAB VALUES IN COLUMNS OF NEXT ROW IN ACTIVE SET
    EXIT WHEN S%NOTFOUND;
    DBMS_OUTPUT.PUT_LINE('ID : '||SOME_NAME||', NAME: '||SOME_WEIGHT||', CAVE_ID: '||SOME_CAVE_ID);
    END LOOP;
    CLOSE S;
END;
/
--TESTING Q2
SELECT BEAR_NAME, WEIGHT FROM BEAR WHERE CAVE_ID = 1 GROUP BY BEAR_NAME, WEIGHT; -- HAVING AVG(WEIGHT) < WEIGHT;
SELECT BEAR_NAME, WEIGHT, CAVE_ID FROM BEAR WHERE WEIGHT > (SELECT AVG(WEIGHT) FROM BEAR) GROUP BY CAVE_ID, BEAR_NAME, WEIGHT;
SELECT AVG(WEIGHT) FROM BEAR;

--STORED PROCEDURES
--TIME TO FEED THE BEARS
--FIRST, REQUIRE THAT BEEHIVES AND BEARS HAVE >=0 AS A WEIGHT

ALTER TABLE BEEHIVE
ADD CONSTRAINT CK_BEEHIVE_WEIGHT
CHECK (HONEY_AMOUNT >0);
/

ALTER TABLE BEAR
ADD CONSTRAINT CK_BEAR_WEIGHT
CHECK (WEIGHT >0);
/

--ADD SOME BEAR/BEEHIVE PAIRINGS
INSERT ALL
INTO BEAR_BEEHIVE
VALUES(72, 1000)
INTO BEAR_BEEHIVE
VALUES(2, 1001)
INTO BEAR_BEEHIVE
VALUES(89, 1001)
INTO BEAR_BEEHIVE
VALUES(89, 1000)
INTO BEAR_BEEHIVE
VALUES(56, 1001)
INTO BEAR_BEEHIVE
VALUES(45, 1001)
SELECT * FROM DUAL;


-- NOW CREATE THE STORED PROCEDURE TO FEED A BEAR
CREATE OR REPLACE PROCEDURE SP_FEED_BEAR(B_ID IN NUMBER, H_ID IN NUMBER, AMT_TO_FEED IN NUMBER, AMT_FED OUT NUMBER)
IS 
--VARIABLE DECLARATIONS
BB_EXISTS INTEGER;
BEGIN
    --CHECK THAT BEAR AND BEEHIVE ARE CORRECTLY MATCHED
    SELECT COUNT(BB.BEAR_ID) INTO BB_EXISTS -- ASSIGN
    FROM BEAR_BEEHIVE BB -- ALIASING BEAR_BEeHIVE
    WHERE BB.BEAR_ID = B_ID
    AND BB.BEEHIVE_ID = H_ID;
    -- IS THERE'S A MATCH AND AMOUNT OF HONEY >0?
    IF BB_EXISTS > 0 AND AMT_TO_FEED > 0 THEN
        --REDUCE HIVE WEIGHT
        UPDATE BEEHIVE SET HONEY_AMOUNT = HONEY_AMOUNT - AMT_TO_FEED
        WHERE BEEHIVE_ID = H_ID;
       
        --INCREASE BEAR WEIGHT
        UPDATE BEAR SET WEIGHT = WEIGHT + AMT_TO_FEED
        WHERE BEAR_ID = B_ID;
        --SET AMOUNT TO RETURN
        AMT_FED := AMT_TO_FEED;
    ELSE
        AMT_FED := 0;
    END IF;
    COMMIT;
    --EXCEPTION HANLING!
    --https://docs.oracle.com/cd/B10501_01/appdev.920/a96624/07_errs.htm
    EXCEPTION
    WHEN OTHERS THEN
    AMT_FED :=0;
    ROLLBACK;
END;
    
DECLARE
AMT_FED NUMBER;
BEGIN
    SP_FEED_BEAR(56,1001,10, AMT_FED);
    DBMS_OUTPUT.PUT_LINE('FED BEAR: '||AMT_FED||' POUNDS OF HONEY');
END;
        









--TROUBLESHOOTING
--SELECT * FROM USER_CONSTRAINTS WHERE TABLE_NAME = "BEAR";
--DROP SEQUENCE SQ_BEAR_PK;
--DROP TABLE BEAR;
/*/
ALTER TABLE BEAR
DROP CONSTRAINT FK_BEAR_BEAR_TYPE;
/
ALTER TABLE BEAR
DROP CONSTRAINT FK_BEAR_CAVE;
/

ALTER TABLE BEAR_BEEHIVE
DROP CONSTRAINT FK_BEAR_BEAR_BEEHIVETYPE;
/

ALTER TABLE BEAR_BEEHIVE
DROP CONSTRAINT FK_BEEHIVE_BEAR_BEEHIVETYPE;
/
DROP SEQUENCE SQ_BEAR_PK
/
DROP SEQUENCE SQ_BEEHIVE_PK
/
DROP SEQUENCE SQ_BEAR_TYPE_PK
/
DROP SEQUENCE SQ_CAVE_PK
/
*/
